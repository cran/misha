<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Manual</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Manual</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(misha)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">gdb.init_examples</span>()</span></code></pre></div>
<div id="package-misha---user-manual" class="section level1">
<h1>Package ‘misha’ - User Manual</h1>
<p><strong>misha</strong> package is intended to help users to
efficiently analyze genomic data achieved from various experiments. The
data must be stored in <em>Genomic Database</em> in certain format that
is described later in this document. In addition the document describes
fundamental concepts of the package such as <em>track expression</em>,
<em>iterators</em>, etc.</p>
<div id="genomic-database" class="section level2">
<h2>Genomic Database</h2>
<p>Genomic Database starts with a <em>root</em> (also frequently
referred as <em>GROOT</em>), i.e. top directory containing certain
subdirectories and files. A new database can be created using
<code>gdb.create</code> function. This is the easiest way to do it. One
can also build a database manually by generating all the necessary
components that will be described later in this document.</p>
<p>Before the data in a Genomic Database can be accessed one must
establish connection with it by calling <code>gdb.init</code> function.
On launch the package connects to a Genomic Database located in
<code>PACKAGEDIR/trackdb/test</code> which serves all the examples in
the reference manual.</p>
<p>A valid Genomic Database should contain the following files and
subdirectories:</p>
<ul>
<li><code>chrom_sizes.txt</code>: is a file containing the list of
chromosomes and their sizes.</li>
<li><code>tracks</code>: is a directory that servers as a repository for
all <em>tracks</em> and <em>interval sets</em>. May contain other
subdirectories.</li>
<li><code>pssms</code>: is a directory containing PSSM sets (PSSM data
and PSSM key files).</li>
<li><code>seq</code>: is a directory containing full genomic
sequences.</li>
</ul>
<p><code>pssms</code> and <code>seq</code> directories are optional and
are required only by a subset of functions in the package.</p>
<p>An example of a Genomic Database file structure:</p>
<pre><code>hg38/              &lt;- Genomic Database root directory
   chrom_sizes.txt
   .ro_attributes  &lt;- List of read-only attributes
   pssms/             &lt;- (optional)
      motif1.data        &lt;- pssm data file
      motif1.key         &lt;- pssm key file
      mypssm.data        &lt;- ...
      mypssm.key         &lt;- ...
   seq/               &lt;- (optional)
      chr1.seq           &lt;- seq (sequence) files
      chr2.seq           &lt;- ...
      chr3.seq           &lt;- ...
   tracks/
      tss.interv         &lt;- small intervals set = tss
      big_data.interv/   &lt;- big intervals set = big_data
         .meta              &lt;- summary of the intervals set
         chr1               &lt;- chrom files
         chr5               &lt;- ...
      rpt.track/         &lt;- track = rpt
         .attributes        &lt;- track attributes (optional)
         chr1               &lt;- chrom files
         chr2               &lt;- ...
         chr3               &lt;- ...
         vars/              &lt;- track variables (optional)
             myresult           &lt;- track variable
      test/
         intervals1.interv  &lt;- intervals = test.intervals1
         track1.track/      &lt;- track = test.track1
         .attributes        &lt;- track attributes (optional)
         chr1               &lt;- chrom files
         chr2               &lt;- ...
         chr3               &lt;- ...
      savta/
         fourC.track/    &lt;- track = savtra.fourC
            chr1               &lt;- chrom files
            chr2               &lt;- ...
            chr3               &lt;- ...</code></pre>
</div>
<div id="file-formats" class="section level2">
<h2>File Formats</h2>
<div id="chrom_sizes.txt" class="section level3">
<h3><code>chrom_sizes.txt</code></h3>
<p><code>chrom_sizes.txt</code> file must be located under the root
directory of Genomic Database. This file lists the chromosomes and their
sizes. The chromosome name appears in the first column, the size is
indicated in the second column. The chromosome name should appear
without “chr” prefix. The two columns are separated by tab character.
Example:</p>
<pre class="tsv"><code>1    247249719
2    242951149
3    199501827
X    154913754
Y    57772954</code></pre>
</div>
<div id="seq-file" class="section level3">
<h3>Seq File</h3>
<p><em>Seq</em> (aka sequence) files are located in <code>seq</code>
directory. Each of the Seq files contains a genomic sequence for a given
chromosome as a contiguous string of ASCII characters. The length of the
string should match the length of the chromosome. The file must be
called <code>chrXXX.seq</code> where <code>XXX</code> indicates the name
of the chromosome as it appears in <code>chrom_sizes.txt</code>
file.</p>
<p>Here is an example of an unusually short (25 base pairs) Seq
file:</p>
<pre class="csv"><code>ggtgaAGccctggagattcttatta</code></pre>
</div>
<div id="pssm-set" class="section level3">
<h3>PSSM Set</h3>
<p>Each <em>PSSM Set</em> consists of two files: <em>PSSM key</em> and
<em>PSSM data</em>. The files should be named <code>XXX.key</code> and
<code>XXX.data</code> accordingly, where <code>XXX</code> is the name of
PSSM set. Both files must be placed into <code>pssms</code>
directory.</p>
<div id="pssm-key" class="section level4">
<h4>PSSM Key</h4>
<p><em>PSSM Key</em> file contains description of PSSMs in the following
format (columns are separated by tab character):</p>
<table>
<colgroup>
<col width="29%" />
<col width="22%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>Integer</td>
<td>Unique ID (referenced in PSSM Data file)</td>
</tr>
<tr class="even">
<td>Sequence</td>
<td>String</td>
<td>PSSM sequence</td>
</tr>
<tr class="odd">
<td>Bidirectional</td>
<td>‘0’ or ‘1’</td>
<td>If Bidirectional is ‘1’ energy is calculated on complementary strand
as well</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="tsv"><code>0    *************ATTAAT**************    1
1    *********A*ACACACACA*****A*******    1
2    *************AAAATGGC*G**********    1
3    *************ACTGCTTG************    1
4    ****WW**GTWGCATACTTTT*GGCG*******    1
5    *********C*RGCAACATKTTG**********    1
6    ****G*G*G*G*GAGCGAGA*RG**********    1
7    **************CCGAAG*************    1</code></pre>
</div>
<div id="pssm-data" class="section level4">
<h4>PSSM Data</h4>
<p><em>PSSM Data</em> file contains probability matrices for each PSSM
key in the following format (columns are separated by tab
character):</p>
<table>
<colgroup>
<col width="29%" />
<col width="22%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>Integer</td>
<td>Unique ID (must appear in PSSM Key file)</td>
</tr>
<tr class="even">
<td>Position</td>
<td>Integer</td>
<td>Zero based position in the range of [0, length(PSSM
sequence)-1]</td>
</tr>
<tr class="odd">
<td>Probability of ‘A’</td>
<td>Numeric</td>
<td>Probability of ‘A’ in the range of [0, 1]</td>
</tr>
<tr class="even">
<td>Probability of ‘C’</td>
<td>Numeric</td>
<td>Probability of ‘C’ in the range of [0, 1]</td>
</tr>
<tr class="odd">
<td>Probability of ‘G’</td>
<td>Numeric</td>
<td>Probability of ‘G’ in the range of [0, 1]</td>
</tr>
<tr class="even">
<td>Probability of ‘T’</td>
<td>Numeric</td>
<td>Probability of ‘T’ in the range of [0, 1]</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="intervals" class="section level2">
<h2>Intervals</h2>
<div id="d-intervals" class="section level3">
<h3>1D Intervals</h3>
<p>A <strong>1D interval</strong> (or one-dimensional interval)
represents a genomic section. It is defined by
<code>(chrom, start, end)</code> where <code>start</code> and
<code>end</code> are genomic coordinates (<code>start &lt; end</code>).
The coordinates are zero-based, meaning the chromosome starts at
coordinate 0. The end coordinate marks the last coordinate in the
section plus 1. To represent a point in the genome at coordinate
<code>X</code>, one should create an interval with start coordinate set
to <code>X</code> and end coordinate set to <code>X + 1</code>.</p>
</div>
<div id="d-intervals-1" class="section level3">
<h3>2D Intervals</h3>
<p>A <strong>2D interval</strong> (or two-dimensional interval)
represents a rectangle in a genomic space. It is defined by
<code>(chrom_1, start_1, end_1, chrom_2, start_2, end_2)</code>, where
<code>start_1, start_2, end_1,</code> and <code>end_2</code> are start
and end coordinates that mark the limits of a rectangle.</p>
</div>
<div id="interval-sets" class="section level3">
<h3>Interval Sets</h3>
<p>Multiple intervals can be combined into a table, known as an
<strong>interval set</strong> or often simply referred to as
<strong>intervals</strong>. This table is represented by a data frame.
In the case of 1D intervals, the data frame must have the first three
columns named <code>chrom</code>, <code>start</code>, and
<code>end</code>. Similarly, 2D intervals must have the first six
columns named <code>chrom1</code>, <code>start1</code>,
<code>end1</code>, <code>chrom2</code>, <code>start2</code>, and
<code>end2</code>.</p>
<p>Additional columns might be added to the intervals, and some of them
might be utilized by various functions. For instance, the
<code>gintervals.neighbors</code> function uses the <code>strand</code>
column if it is presented in 1D intervals (should come after the regular
three columns). Use <code>gintervals</code> and
<code>gintervals.2d</code> functions to create 1D and 2D intervals,
respectively.</p>
<p>Both 1D and 2D intervals are prevalent in various functions. Some of
these functions manipulate the intervals (unify, intersect, etc.).
Others use the intervals to limit the function’s scope. There are also
functions that perform their calculation for each interval in the
interval set.</p>
</div>
<div id="dual-intervals" class="section level3">
<h3>Dual Intervals</h3>
<p><strong>Dual intervals</strong> is a list containing two elements.
The first element is a 1D interval set, while the second element is a 2D
interval set.</p>
<p>The <code>.misha$ALLGENOME</code> variable is frequently used as a
default value for the intervals argument. <code>.misha$ALLGENOME</code>
is an interval set of a dual type. <code>.misha$ALLGENOME[[1]]</code>
represents a set of intervals that cover the entire genome (1D), while
<code>.misha$ALLGENOME[[2]]</code> contains all the possible pairs
between the chromosomes (2D). One can also use
<code>gintervals.all</code> and <code>gintervals.2d.all</code> functions
to return all 1D or 2D intervals.</p>
</div>
<div id="serializing-intervals-big-and-small-interval-sets" class="section level3">
<h3>Serializing Intervals, Big and Small Interval Sets</h3>
<p>Interval sets can be saved in the Genomic Database. Use the
<code>gintervals.save</code> and <code>gintervals.load</code> functions
to save or load an interval set from the database, and
<code>gintervals.update</code> to update/add/delete a certain chromosome
from the set.</p>
<p>Internally, interval sets can be stored in two different formats:
<strong>small interval set</strong> or <strong>big interval
set</strong>. The specific format is chosen depending on the size of the
interval set. Big format is selected for interval sets that contain more
than <code>gbig.intervals.size</code> intervals
(<code>gbig.intervals.size</code> is set via <code>options</code>),
while smaller sets are stored in the small format. Use
<code>gintervals.is.bigset</code> to determine the format of the stored
interval set.</p>
<p>Saved interval sets in the small format can be seamlessly used in all
functions and track expressions without the need to explicitly load
them.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># &#39;annotations&#39; is an intervals set saved in Genomic Database</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">gintervals.intersect</span>(<span class="st">&quot;annotations&quot;</span>, <span class="fu">gintervals</span>(<span class="dv">2</span>))</span></code></pre></div>
<p>Likewise, big interval sets can be used in many but not all
functions. A notable exception is <code>gintervals.load</code> that
allows loading only a single chromosome (or a chromosome pair for 2D
cases) of a big intervals set.</p>
</div>
</div>
<div id="tracks" class="section level2">
<h2>Tracks</h2>
<p>A <strong>Track</strong> is a data structure that allows binding
numeric data (floating point values) to a genomic space (a set of
genomic intervals). The data in the tracks can typically be accessed
through <strong>track expressions</strong> that are widely used by
various functions of the package.</p>
<p>Two fundamental types of tracks exist: <strong>1D</strong> and
<strong>2D</strong>.</p>
<div id="d-track" class="section level3">
<h3>1D Track</h3>
<p>A <strong>1D track</strong> (or one-dimensional track) maps numeric
values <span class="math inline">\(V_0, ..., V_n\)</span> to
non-overlapping 1D intervals. The package supports two formats of 1D
tracks: <strong>Dense</strong> (sometimes also referred to as
<strong>Fixed Bin</strong>) and <strong>Sparse</strong>.</p>
<p>For a Dense track, the size of the genomic interval is always fixed
and called <strong>bin size</strong>. Numeric values are stored for all
genomic intervals that cover the genome, although some values can be
<code>NaN</code>. A Dense track file appears as a continuous chunk of
values <span class="math inline">\(V_0, ..., V_n\)</span>, where <span class="math inline">\(V_i\)</span> maps to an interval <span class="math inline">\([binsize * i, binsize * (i+1))\)</span>. Dense
track files do not store interval coordinates, allowing them to
represent large amounts of numeric data compactly. The size of a Dense
track is inversely proportional to the bin size. Random access to a
value at a given coordinate has constant complexity, i.e., <span class="math inline">\(O(1)\)</span>.</p>
<p>Sparse tracks offer more flexibility compared to Dense tracks. Each
numeric value can map to a genomic interval of any size. The size of a
Sparse track is proportional to the number of numeric values (excluding
<code>NaN</code>s). On the downside, the complexity of random access to
a value at a given coordinate is <span class="math inline">\(O(logN)\)</span>, where <span class="math inline">\(N\)</span> is the number of values in the
track.</p>
<p>To summarize the differences between Dense and Sparse tracks:</p>
<table>
<colgroup>
<col width="16%" />
<col width="41%" />
<col width="41%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Dense</th>
<th>Sparse</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Optimal use case</td>
<td>Data covering nearly the whole genome</td>
<td>Data covering a limited portion of the genome</td>
</tr>
<tr class="even">
<td>Values stored</td>
<td>Per bin (interval of a fixed size)</td>
<td>Per interval of an arbitrary size</td>
</tr>
<tr class="odd">
<td>Random access complexity</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(logN)\)</span></td>
</tr>
<tr class="even">
<td>Disk usage</td>
<td>4 bytes per bin</td>
<td>20 bytes per value</td>
</tr>
</tbody>
</table>
<p>1D tracks can be created by various functions, such as
<code>gtrack.create</code>, <code>gtrack.create_sparse</code>,
<code>gtrack.import_set</code>, and more.</p>
</div>
<div id="array-track" class="section level3">
<h3>Array Track</h3>
<p>An <strong>Array track</strong> is similar to a Sparse track in that
it maps data to one-dimensional intervals of any size. However, unlike
Sparse tracks, an Array track can map multiple values to each interval.
Array tracks thus store large amounts of data in one track - a task that
would otherwise require numerous tracks.</p>
<p>The values in an Array track are organized into
<strong>columns</strong>, each with a name and an index. You can view it
as an NxM table, where N is the number of intervals, and M is the number
of columns. The size of an Array track is proportional to the total
number of numeric values stored (excluding <code>NaN</code>s).</p>
<p>As useful as they are, Array tracks should not replace Dense or
Sparse tracks. A single Sparse track will always be more compact and
efficient than an Array track holding only one column.</p>
<p>You can create Array tracks with the <code>gtrack.array.import</code>
function.</p>
</div>
<div id="d-track-1" class="section level3">
<h3>2D Track</h3>
<p>A <strong>2D track</strong> (or two-dimensional track) maps numeric
values <span class="math inline">\(V_0, ..., V_n\)</span> to
non-overlapping 2D intervals. These are often used to represent
interactions between different parts of the genome.</p>
<p>2D tracks are stored internally in <strong>chunks</strong> with each
chunk containing multiple track values. When accessing a track value,
its entire chunk is loaded into memory. The byte size of a chunk,
determined by the <code>gtrack.chunk.size</code> option, is a tradeoff
between single value access (smaller chunk) and multiple value access
(larger chunk).</p>
<p>When accessing multiple track values, multiple chunks might be loaded
into memory. Given the potential size of 2D tracks, the total number of
chunks in memory can be limited using the <code>gtrack.num.chunks</code>
parameter.</p>
<p>Typically, 2D tracks use the <strong>Rectangles</strong> format.
However, a more space-efficient <strong>Points</strong> format exists,
similar in behavior to Rectangles. There’s also a
<strong>Computed</strong> format, which is beyond the scope of this
documentation.</p>
<p>Rectangles tracks: <code>gtrack.create</code>,
<code>gtrack.2d.create</code>.</p>
<p>Points tracks: <code>gtrack.2d.import_contacts</code>.</p>
</div>
<div id="track-as-an-intervals-set" class="section level3">
<h3>Track as an Intervals Set</h3>
<p>Tracks represent sets of intervals, augmented with values, and can
therefore replace interval sets in functions like <code>gextract</code>,
<code>gintervals.neighbors</code>, and
<code>gintervals.chrom_sizes</code>. The only exception is
<strong>Dense</strong> tracks which can’t be used in place of interval
sets.</p>
</div>
<div id="track-attributes" class="section level3">
<h3>Track Attributes</h3>
<p>Beyond numeric data, tracks can store metadata, such as descriptions
or sources. This metadata is stored as name-value pairs or attributes
with the value being a string. Tracks created using
<code>gtrack.create</code>, <code>gtrack.smooth</code>, etc.,
automatically have <code>created.by</code>, <code>created.date</code>,
and <code>description</code> attributes.</p>
<p>While there’s no strict rule, attributes typically store short
strings. For other data formats, consider using <strong>track
variables</strong>.</p>
<p>Attribute management: - Retrieval/Modification:
<code>gtrack.attr.get</code>, <code>gtrack.attr.set</code>. - Bulk
Actions: <code>gtrack.attr.export</code>,
<code>gtrack.attr.import</code>. - Search by Pattern:
<code>gtrack.ls</code>.</p>
<p>Some attributes are read-only, like <code>created.by</code> and
<code>created.date</code>. Use <code>gdb.get_readonly_attrs</code> and
<code>gdb.set_readonly_attrs</code> to manage these.</p>
</div>
<div id="track-variables" class="section level3">
<h3>Track Variables</h3>
<p>Track variables store statistics, computation results, historical
data, etc., related to a track. Unlike attributes, they can store data
in any format.</p>
<p>Variable management: - Retrieval/Modification/Removal:
<code>gtrack.var.get</code>, <code>gtrack.var.set</code>,
<code>gtrack.var.rm</code>. - List variables:
<code>gtrack.var.ls</code>.</p>
</div>
<div id="track-attributes-vs.-track-variables" class="section level3">
<h3>Track Attributes vs. Track Variables</h3>
<p>Both track attributes and variables store track metadata, but they
have distinct uses:</p>
<table>
<colgroup>
<col width="34%" />
<col width="20%" />
<col width="44%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Track Attributes</th>
<th>Track Variables</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Use Case</td>
<td>Track metadata as short strings (e.g., description)</td>
<td>Arbitrary track-associated data</td>
</tr>
<tr class="even">
<td>Value Type</td>
<td>String</td>
<td>Any</td>
</tr>
<tr class="odd">
<td>Single Value Retrieval</td>
<td><code>gtrack.attr.get</code></td>
<td><code>gtrack.var.get</code></td>
</tr>
<tr class="even">
<td>Single Value Modification</td>
<td><code>gtrack.attr.set</code></td>
<td><code>gtrack.var.set</code></td>
</tr>
<tr class="odd">
<td>Bulk Retrieval</td>
<td><code>gtrack.attr.export</code></td>
<td>N/A</td>
</tr>
<tr class="even">
<td>Bulk Modification</td>
<td><code>gtrack.attr.import</code></td>
<td>N/A</td>
</tr>
<tr class="odd">
<td>Object Names Retrieval</td>
<td><code>gtrack.attr.export</code></td>
<td><code>gtrack.var.ls</code></td>
</tr>
<tr class="even">
<td>Object Removal</td>
<td><code>gtrack.attr.set</code> (with an empty string)</td>
<td><code>gtrack.var.rm</code></td>
</tr>
<tr class="odd">
<td>Search by Value</td>
<td><code>gtrack.ls</code></td>
<td>N/A</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="track-expressions" class="section level2">
<h2>Track Expressions</h2>
<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p><em>Track expression</em> is a key concept of the package. Track
expressions are widely used in various functions (<code>gscreen</code>,
<code>gextract</code>, <code>gdist</code>, …).</p>
<p>Track expression is a character string that closely resembles a valid
R expression. Just like any other R expression it may include
conditions, functions and variables defined beforehand.
<code>&quot;1 &gt; 2&quot;</code>, <code>&quot;mean(1:10)&quot;</code> and
<code>&quot;myvar &lt; 17&quot;</code> are all valid track expressions. Unlike
regular R expressions track expression might also contain track names or
<em>virtual track</em> names.</p>
<p>How does a track expression get evaluated? A track expression is
accompanied by an <em>iterator</em> that determines a set of intervals
over which the expression iterator goes. For each each iterator interval
the track expression is evaluated. The value of a track expression
<code>&quot;mean(1:10)&quot;</code> is constant regardless the iterator interval.
However suppose the track expression contains a track name
<code>mytrack</code>, like: <code>&quot;mytrack * 3&quot;</code>, and the whole
story becomes very different. The library first recognizes that
<code>mytrack</code> is not a regular R variable but rather a track
name. A new R variable named <code>mytrack</code> is added then to R
environment. For each iterator interval this variable is assigned the
corresponding value of the track. This value obviously depends on the
iterator interval. Once <code>mytrack</code> is assigned the
corresponding value, the track expression is evaluated in R.</p>
<p>So how exactly the value of <code>mytrack</code> variable is
determined given the iterator interval? We will demonstrate the answer
by the following example. Suppose the track <code>mytrack</code> is in
sparse format. It consists of a single chromosome with the following
values:</p>
<table>
<thead>
<tr class="header">
<th>chrom</th>
<th>start</th>
<th>end</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>chr1</td>
<td>100</td>
<td>200</td>
<td>10</td>
</tr>
<tr class="even">
<td>chr1</td>
<td>200</td>
<td>250</td>
<td>25</td>
</tr>
<tr class="odd">
<td>chr1</td>
<td>500</td>
<td>560</td>
<td>17</td>
</tr>
<tr class="even">
<td>chr1</td>
<td>600</td>
<td>700</td>
<td>44</td>
</tr>
</tbody>
</table>
<p>What would be the value of the variable <code>mytrack</code> given an
iterator interval? The resulted value is an average of all values of
track <code>mytrack</code> covered by the iterator interval. For
example, if the iterator interval is <code>[230, 620)</code> then the
resulted value is an average of values 25, 17 and 44. Similarly if the
iterator interval is <code>[0, 300)</code> then the resulted value is an
average of 10 and 25. Lastly if the iterator intervals is
<code>[300, 400)</code> then the resulted value is <span class="math inline">\(NaN\)</span>. Same evaluation logics is applied
for Dense and Array tracks. (In the latter case the values from all
columns are averaged.) On contrary Rectangles track value is calculated
as a <em>weighted</em> average of the values covered by the iterator
interval. The weight equals to the intersection area of the iterator
interval and the 2D interval that contains the value.</p>
<p>See the table below:</p>
<table>
<colgroup>
<col width="65%" />
<col width="35%" />
</colgroup>
<thead>
<tr class="header">
<th>Track Type</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dense</td>
<td>Average of non <span class="math inline">\(NaN\)</span> values
covered by iterator interval.</td>
</tr>
<tr class="even">
<td>Sparse</td>
<td>Average of non <span class="math inline">\(NaN\)</span> values
covered by iterator interval.</td>
</tr>
<tr class="odd">
<td>Array</td>
<td>Average of non <span class="math inline">\(NaN\)</span> values from
all columns covered by iterator interval.</td>
</tr>
<tr class="even">
<td>Rectangles</td>
<td>Weighted average of non <span class="math inline">\(NaN\)</span>
values covered by iterator interval. Each weight equals to the
intersection area between iterator interval and track interval that
contains the value.</td>
</tr>
</tbody>
</table>
</div>
<div id="virtual-tracks" class="section level3">
<h3>Virtual Tracks</h3>
<p>So far we showed that the value of a <code>mytrack</code> variable is
set to be the average (or weighted average) of the track values that are
covered by the iterator interval. But what if we do not want to average
the values but rather pick up the maximal or minimal values? What if we
want to use the percentile of a track value rather than the value
itself? And maybe we even want to alter the iterator interval itself on
the fly? This is where virtual tracks become useful.</p>
<p>Virtual track is a set of rules that describe how the “source” (a
real track or intervals) should be proceeded, and how the iterator
interval should be modified. Virtual tracks are created with
<code>gvtrack.create</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">gvtrack.create</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="st">&quot;dense_track&quot;</span>)</span></code></pre></div>
<p>This call creates a new virtual track named <code>myvtrack</code>.
This virtual track can be used in the track expression instead of a real
track <code>dense_track</code>. In our example <code>myvtrack</code> is
just an alias of <code>dense_track</code>. Yet we can go on and create a
more complicated virtual track if we specify a “function”, i.e. instruct
the virtual track of what should be its value in track expression.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">gvtrack.create</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="st">&quot;dense_track&quot;</span>, <span class="st">&quot;global.percentile&quot;</span>)</span></code></pre></div>
<p>In this example when <code>myvtrack</code> is evaluated in the track
expression it will return the percentile of <span class="math inline">\(V_{avg}\)</span> among the values of
<code>dense_track</code> where <span class="math inline">\(V_{avg}\)</span> is an average (or weighted
average) of the track values that are covered by the iterator
interval.</p>
<p>Virtual tracks are especially useful for Array tracks. By default if
an Array track is used in a track expressions, its interval value would
be the average of all non-NaN column values covered by an iterator
interval. <code>gvtrack.array.slice</code> allows to select specific
columns and to specify the function applied to the values of each track
interval.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">gvtrack.create</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="st">&quot;array_track&quot;</span>, <span class="st">&quot;sum&quot;</span>)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="fu">gvtrack.array.slice</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="fu">c</span>(<span class="st">&quot;col2&quot;</span>, <span class="st">&quot;col5&quot;</span>), <span class="st">&quot;max&quot;</span>)</span></code></pre></div>
<p>In this example we create a virtual track based on
<code>array_track</code>. Assume that an iterator interval <span class="math inline">\(I\)</span> covers <span class="math inline">\(n\)</span> different intervals in
<code>array_track</code>: <span class="math inline">\(I_0, ...,
I_n\)</span>. The value of <code>myvtrack</code> in a track expression
would be then: <span class="math display">\[ \sum_{i=1}^{n}max(V_{i,2},
V_{i,5}) \]</span> where <span class="math inline">\(V_{i,j}\)</span> is
a value of the track in column <span class="math inline">\(j\)</span>
for interval <span class="math inline">\(I_i\)</span>.</p>
<p>Virtual tracks allow also to alter the iterator interval “on the
fly”:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">gvtrack.iterator</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="at">sshift =</span> <span class="sc">-</span><span class="dv">100</span>, <span class="at">eshift =</span> <span class="dv">200</span>)</span></code></pre></div>
<p>In this example we expand each iterator interval by adding -100 to
its <code>start</code> coordinate and 200 to its <code>end</code>
coordinate.</p>
<p>Similarly, iterator modifiers can be defined for 2D intervals.
Moreover, an iterator modifier can create a 1D interval from a 2D
iterator interval by projecting one of its axes.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">gvtrack.create</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="st">&quot;dense_track&quot;</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">gvtrack.iterator</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="at">dim =</span> <span class="dv">2</span>)</span></code></pre></div>
<p>It is important to remember that iterator modifiers transform the
iterator interval only for the given virtual tracks. Assume an iterator
interval <span class="math inline">\(I\)</span> and two virtual tracks
<span class="math inline">\(V_0\)</span> and <span class="math inline">\(V_1\)</span>. If <span class="math inline">\(I\)</span> is a 2D interval then <em>band</em>
rules are applied first to it. <span class="math inline">\(I\)</span> is
transformed then to <span class="math inline">\(I_0\)</span> and <span class="math inline">\(I_1\)</span> according to the modification rules
defined by the virtual tracks. Finally, <span class="math inline">\(I_0\)</span> and <span class="math inline">\(I_1\)</span> are passed to <span class="math inline">\(V_0\)</span> and <span class="math inline">\(V_1\)</span> accordingly as the iterator
intervals.</p>
<p>So far we have used a track <code>dense_track</code> as a “source” of
a virtual track. We can also use intervals as a source. In this case,
the value of the virtual track will be some function that takes into
account the “source” intervals and the current iterator interval.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">gvtrack.create</span>(<span class="st">&quot;myvtrack&quot;</span>, <span class="st">&quot;annotations&quot;</span>, <span class="st">&quot;distance&quot;</span>)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>intervs <span class="ot">&lt;-</span> <span class="fu">gscreen</span>(<span class="st">&quot;dense_track &gt; 0.45&quot;</span>)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="fu">gextract</span>(<span class="st">&quot;myvtrack&quot;</span>, .misha<span class="sc">$</span>ALLGENOME, <span class="at">iterator =</span> intervs)</span></code></pre></div>
<p>In this example <code>myvtrack</code> returns the minimal distance
between intervals from an interval set <code>annotations</code> and the
center of the current iterator interval from <code>intervs</code>.</p>
<p>For a full list of supported functions please see
<code>gvtrack.create</code> and <code>gvtrack.array.slice</code>
functions.</p>
</div>
<div id="administrating-virtual-tracks" class="section level3">
<h3>Administrating Virtual Tracks</h3>
<p>As described in the previous chapter virtual tracks define a set of
rules of how to access and proceed the values of the “source” object.
The connection between the virtual track and the source object is done
via “soft link”, i.e. by name and not by reference. For example, a
virtual track will continue to exist until explicitly removed by
<code>gvtrack.rm</code> even if the physical track that it is pointing
to is deleted or renamed.</p>
<p>Operations such as <code>gdb.init</code> and <code>gdir.cd</code>
alter the list of available tracks and intervals sets. Since these
objects are referenced by virtual tracks, these latter are always
defined in the context of the current working directory in Genomic
Database (not to be confused with shell’s current working directory).
Changing the current working directory using <code>gdb.init</code> or
<code>gdir.cd</code> will also change the list of available virtual
tracks.</p>
<p>Another issue to bare in mind is that unlike regular tracks whose
data is stored on disk virtual tracks are non-persistent objects in
current R environment. Their definition is stored in
<code>GVTRACKS</code> R variable. In particular a virtual track named
“vtrack” that was created within a context of “/home/user/trackdb”
Genomic Database working directory would reside in
<code>GVTRACKS[[&quot;/home/user/trackdb&quot;]][[&quot;vtrack&quot;]]</code>. One can also
use <code>gvtrack.info</code> function that provides a more convenient
access to virtual track definitions.</p>
<p>As the virtual tracks are stored in an R variable their behavior
hence complies with the rules of other R variables: a virtual track
defined by one user will not be seen by another one, virtual tracks
might disappear once R is relaunched, etc.</p>
<p>To preserve the definition of virtual tracks between the sessions one
would need to save <code>GVTRACKS</code> variable on disk. The
serialization of <code>GVTRACKS</code> is under user’s responsibility.
The standard suit of functions for saving / loading R variables can be
used for that purpose.</p>
<p>Note that if <code>GVTRACKS</code> is loaded from a file or changed
manually by a user the <em>auto-completion</em> list (in case it is
turned on) might need to be refreshed by calling
<code>gdb.reload</code>.</p>
</div>
<div id="track-expression-evaluation-under-optimization" class="section level3">
<h3>Track Expression Evaluation under Optimization</h3>
<p>Previously we described how a track expression
<code>&quot;mytrack * 3&quot;</code> (where <code>mytrack</code> is a track name)
leads to an implicit definition of <code>mytrack</code> variable in R
environment. To make our explanation easier we presented this variable
as a scalar whose value is altered each time the iterator interval
changes. It’s time to admit that that was oversimplification. In reality
the library defines <code>mytrack</code> variable as a vector (i.e. an
array) and not as a single scalar. The vector is filled then with the
corresponding values of the track. Finally the track expression is
evaluated in R and the result is expected to be also a vector of the
same size as <code>mytrack</code> vector. Working with vectors rather
than single scalars reduces the number of evaluations within R and hence
improves run-times.</p>
<p>The size of the vector is controlled via <code>gbuf.size</code>
option. By default it equals to 1000. Altering this value (for instance
setting it to 1) might significantly affect the run-time of various
functions in the library. If you still wish to force the functions to
define scalars rather than vectors, set <code>gbuf.size</code> to 1:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">gbuf.size =</span> <span class="dv">1</span>)</span></code></pre></div>
<p>One might wonder why should we care about the fact that
<code>mytrack</code> is not a scalar but rather a vector? Indeed in many
cases it does not really matter. For example <code>mytrack * 3</code>
expression produces exactly the same results regardless whether
<code>mytrack</code> is defined internally as a vector or as a scalar.
This is due to the fact that the expression <code>V * 3</code>
(<code>V</code> stands for a vector) results in each value of
<code>V</code> being multiplied by 3.</p>
<p>Multiplication is a good example of “parallel” operation in R (works
on each element in vector separately). On contrary some functions that
accept a vector might return a scalar rather than a vector. Such is, for
example, <code>min</code> function.</p>
<p>Let’s look at the following track expression:
<code>track1 + min(track1, track2)</code>. This expression was probably
meant to produce a sum of <code>track1</code> track and a minimum value
between <code>track1</code> and <code>track2</code> tracks for each
iterator interval. However the library defines the variables
<code>track1</code> and <code>track2</code> to be vectors of
<code>gbuf.size</code> size (by default: 1000). <code>min</code> is not
a “parallel” operation. Given two vectors of any size it returns a
single scalar that is the minimal value of <em>all</em> values in both
of the vectors. Therefore <code>track1 + min(track1, track2)</code> will
be interpreted as <code>track1 + M</code>, where M is minimum of 2000
values (1000 values from <code>track1</code> track, and another 1000 -
from <code>track2</code> track). We can hardly imagine that a user would
have really meant this! Sadly enough the expression will be seamlessly
evaluated and produce a valid, but meaningless result. The solution for
our example is to use <code>pmin</code> rather than <code>min</code>
function.</p>
<p>The library always verifies that the evaluation of the track
expression produces a vector of the same size as the size of a track
variable. In many cases this procedure is able to reveal faulty track
expressions. Yet in more tricky examples like the one that we used
before the library will not warn the user.</p>
<blockquote>
<p>Make sure your track expressions work correctly on vectors!</p>
</blockquote>
</div>
<div id="revealing-current-iterator-interval" class="section level3">
<h3>Revealing Current Iterator Interval</h3>
<p>During the evaluation of a track expression one can access a
specially defined variable named <code>GITERATOR.INTERVALS</code>. This
variable contains a set of iterator intervals for which the track
expression is evaluated. <code>GITERATOR.INTERVALS</code> contains the
same number of intervals as the size of <code>mytrack</code> vector from
our previous example. The value of a track <code>mytrack</code> for an
interval <code>i</code> is stored at <code>mytrack[i]</code>.</p>
<p>Note that some intervals in <code>GITERATOR.INTERVALS</code> might
have a start coordinate equal to -1. Skip those intervals and the values
of <code>mytrack</code> at the corresponding index.</p>
</div>
<div id="iterators" class="section level3">
<h3>Iterators</h3>
<p>So far we have discussed in details how the track expression is
evaluated given the <em>iterator interval</em>. Yet how the iterator
intervals can be controlled?</p>
<p>Most of the functions that accept track expressions have an
additional parameter named <code>iterator</code>. The value of this
parameter determines the iterator intervals which is also sometimes
called an <em>iterator policy</em>:</p>
<table>
<colgroup>
<col width="13%" />
<col width="10%" />
<col width="19%" />
<col width="57%" />
</colgroup>
<thead>
<tr class="header">
<th>Value</th>
<th>Iterator Policy Type</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Integer</td>
<td>Fixed Bin</td>
<td><code>50</code></td>
<td>Iterator intervals will advance by a fixed step (bin) starting from
zero coordinate up to chromosome’s length:
<code>[0,50), [50,100), [100,150), ...</code></td>
</tr>
<tr class="even">
<td>Dense track</td>
<td>Fixed Bin</td>
<td><code>&quot;dense_track&quot;</code></td>
<td>Use the bin size of the track as a fixed step.</td>
</tr>
<tr class="odd">
<td>1D intervals</td>
<td>1D Intervals</td>
<td><code>&quot;annotations&quot;</code></td>
<td>Iterate over the supplied intervals. <em>Note: the intervals are
sorted and overlapping intervals are unified.</em></td>
</tr>
<tr class="even">
<td>Sparse track</td>
<td>1D Intervals</td>
<td><code>&quot;sparse_track&quot;</code></td>
<td>Iterate over the intervals of a sparse track.</td>
</tr>
<tr class="odd">
<td>Array track</td>
<td>1D Intervals</td>
<td><code>&quot;array_track&quot;</code></td>
<td>Iterate over the intervals of an array track.</td>
</tr>
<tr class="even">
<td>c(integer, integer)</td>
<td>2D Intervals</td>
<td><code>c(1000, 2000)</code></td>
<td>2D iterator intervals will cover the whole 2D chromosomal space by
rectangles of fixed size: Width X Height. Please keep in mind that small
rectangles used without a limiting scope might result in immense number
of iterator intervals.</td>
</tr>
<tr class="odd">
<td>2D intervals</td>
<td>2D Intervals</td>
<td><code>gintervals.2d(c(1, 2))</code></td>
<td>Iterate over the supplied intervals. <em>Note: the intervals are
sorted and overlapping is forbidden.</em></td>
</tr>
<tr class="even">
<td>Rectangles track</td>
<td>2D Intervals</td>
<td><code>&quot;rects_track&quot;</code></td>
<td>Iterate over the intervals of a Rectangles track</td>
</tr>
<tr class="odd">
<td>Cartesian grid iterator</td>
<td>2D Intervals</td>
<td><code>giterator.cartesian_grid( intervals1, intervals2, c(10, 20, 30))</code></td>
<td>Iterate over 2D cartesian grid (see
<code>giterator.cartesian_grid</code> function)</td>
</tr>
<tr class="even">
<td>NULL</td>
<td>Fixed Bin OR 1D Intervals OR 2D Intervals</td>
<td>NULL</td>
<td>Implicitly determine the iterator policy based on the tracks that
appear in the track expression. If no track names presented or two
different tracks determine different iterator policy, an error is
reported.</td>
</tr>
</tbody>
</table>
</div>
<div id="scope" class="section level3">
<h3>Scope</h3>
<p>Many functions that accept a track expressions and iterator policy
accept an additional set of intervals that limit the scope of a
function. This scope also limits the iterator intervals. For
instance:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">gextract</span>(<span class="st">&quot;dense_track&quot;</span>, <span class="fu">gintervals</span>(<span class="dv">2</span>, <span class="dv">340</span>, <span class="dv">520</span>))</span></code></pre></div>
<p>As one can notice the first and the last intervals in the result are
truncated by the scope <code>[340, 520)</code>.</p>
<p>In some cases the combination of iterator policy and scope might
result in nontrivial set of iterator intervals. Use
<code>giterator.intervals</code> function to retrieve the iterator
intervals given a track expression, scope and an iterator.</p>
</div>
<div id="band" class="section level3">
<h3>Band</h3>
<p>As explained before track expression iterator can be determined
implicitly or through an <code>iterator</code> parameter. In either case
the result is a set of 1D or 2D intervals depending on how the iterator
was defined. If iterator intervals are 2D an additional filter can be
applied to them: a <em>band</em>.</p>
<p>A band is a pair of integers: <span class="math inline">\(D_1,
D_2\)</span>. We say that a 2D iterator interval <span class="math inline">\((chrom_1, x_1, x_2, chrom_2, y_1, y_2)\)</span>
intersects a band if and only if the next two conditions are true:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(chrom_1 = chrom_2\)</span></li>
<li><span class="math inline">\(\exists x,y: x_1 \le x &lt; x_2 \wedge
y_1 \le y &lt; y_2 \wedge D_1 \le x-y &lt; D_2\)</span>.</li>
</ol>
<p>In a less formal way we can see a band as a space <span class="math inline">\(S\)</span> between two 45-degrees diagonals where
<span class="math inline">\(D1, D2\)</span> determine where these
diagonals cross <span class="math inline">\(X\)</span> axis. An iterator
interval represents a rectangle in a 2D space and can be therefore
intersected with S. The result of the intersection can be a rectangle, a
trapeze, a triangle, a hexagon or it can be empty if the interval does
not intersect with the band. If the intersection is non empty, the
resulted figure, whatever it is, can be bound by some larger rectangle.
The rectangle that has the minimal space and yet containing the
intersected shape is called <em>the minimal rectangle</em>.</p>
<p>After the formal definitions it’s time to say how band is actually
applied.</p>
<p>If the intersection between the 2D iterator interval and the band is
non-empty and <span class="math inline">\(chrom_1=chrom_2\)</span>, the
minimal rectangle replaces the original iterator interval. Otherwise the
iterator interval is skipped as it lies outside of the band or the two
chromosomes are not equal.</p>
<p>The <code>gintervals.2d.band_intersect</code> function can help one
better understand the concept:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>intervs <span class="ot">&lt;-</span> <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="dv">200</span>, <span class="dv">800</span>, <span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">1000</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>intervs <span class="ot">&lt;-</span> <span class="fu">rbind</span>(intervs, <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="dv">900</span>, <span class="dv">950</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">200</span>))</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>intervs <span class="ot">&lt;-</span> <span class="fu">rbind</span>(intervs, <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">400</span>))</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>intervs <span class="ot">&lt;-</span> <span class="fu">rbind</span>(intervs, <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="dv">900</span>, <span class="dv">950</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">200</span>))</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>intervs</span></code></pre></div>
<p><code>gintervals.2d.band_intersect</code> intersects the intervals
with the band and returns the intervals shrunk to the minimal rectangle.
As you can see we have four different intervals. The first one
<code>(chr1, 200, 800, chr1, 100, 1000)</code> intersects the band and
after shrinking to the minimal rectangle it becomes
<code>(chr1, 600, 800, chr1, 100, 300)</code>. The second interval lies
entirely within the band and hence is returned without any change. The
third interval lies entirely outside of the band, and hence is
eliminated from the result. The last interval is coming from two
different chromosomes and therefore is also filtered out.</p>
<p>As said band filters out and alters 2D iterator intervals. Yet it
also affects the result of 2D tracks. Let’s look at the following
example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>intervs <span class="ot">&lt;-</span> <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">400</span>), <span class="fu">c</span>(<span class="dv">300</span>, <span class="dv">490</span>), <span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">120</span>, <span class="dv">180</span>), <span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">500</span>))</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="fu">gtrack.2d.create</span>(<span class="st">&quot;test2d&quot;</span>, <span class="st">&quot;test 2D track&quot;</span>, intervs, <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">20</span>))</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="fu">gextract</span>(<span class="st">&quot;test2d&quot;</span>, .misha<span class="sc">$</span>ALLGENOME)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="fu">gextract</span>(<span class="st">&quot;test2d&quot;</span>, .misha<span class="sc">$</span>ALLGENOME, <span class="at">iterator =</span> <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1000</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1000</span>))</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="fu">gintervals.2d.band_intersect</span>(intervs, <span class="at">band =</span> <span class="fu">c</span>(<span class="dv">150</span>, <span class="dv">1000</span>))</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="fu">gextract</span>(<span class="st">&quot;test2d&quot;</span>, .misha<span class="sc">$</span>ALLGENOME, <span class="at">iterator =</span> <span class="fu">gintervals.2d</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1000</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1000</span>), <span class="at">band =</span> <span class="fu">c</span>(<span class="dv">150</span>, <span class="dv">1000</span>))</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="fu">gtrack.rm</span>(<span class="st">&quot;test2d&quot;</span>, <span class="at">force =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>We created a 2D track <code>test2d</code> and inserted two values
into it: <span class="math inline">\(10\)</span> and <span class="math inline">\(20\)</span>. If an iterator interval covers all
the track’s rectangles, the resulted value of the track would be a
weighted average of its values where the weight is equal to the
intersected area. In our example it is <span class="math inline">\(16.42857\)</span>.</p>
<p>We added a band then. <code>gintervals.2d.band_intersect</code> shows
the minimal rectangles: the intersection result of the original
rectangles with the band. The output of the new <code>gextract</code>
has been changed accordingly: the new weights in the weighted average
are equal to the new and smaller intersected area. The value has changed
therefore to: <span class="math inline">\(19.57182\)</span>.</p>
<blockquote>
<p>Note, however, that the space used in the calculation of the weighted
average is the actual space of the intersection and not the space
occupied by the minimal rectangles!</p>
</blockquote>
</div>
</div>
<div id="random-algorithms" class="section level2">
<h2>Random Algorithms</h2>
<p>Various functions in the library such as <code>gsample</code> make
use of pseudo-random number generator. Each time the function is invoked
a unique series of random numbers is issued. Hence two identical calls
might produce different results. To guarantee reproducible results call
<code>set.seed</code> before invoking the function.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">60427</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>r1 <span class="ot">&lt;-</span> <span class="fu">gsample</span>(<span class="st">&quot;dense_track&quot;</span>, <span class="dv">10</span>)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>r2 <span class="ot">&lt;-</span> <span class="fu">gsample</span>(<span class="st">&quot;dense_track&quot;</span>, <span class="dv">10</span>) <span class="co"># r2 differs from r1</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">60427</span>)</span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>r3 <span class="ot">&lt;-</span> <span class="fu">gsample</span>(<span class="st">&quot;dense_track&quot;</span>, <span class="dv">10</span>) <span class="co"># r3 == r1</span></span></code></pre></div>
</div>
<div id="multitasking" class="section level2">
<h2>Multitasking</h2>
<div id="controlling-the-number-of-processes" class="section level3">
<h3>Controlling the Number of Processes</h3>
<p>To boost the run time performance various functions in the library
support multitasking mode, i.e. parallel computation of the result by
several concurrent processes. The exact number of processes internally
launched depends on the specific call however the upper bound can be
controlled by a few parameters such as <code>gmax.processes</code>
(absolute upper bound), <code>gmax.processes2core</code> (maximal number
of processes per CPU core) and <code>gmin.scope4process</code> (minimal
scope range / surface assigned to a process). Multitasking can also be
completely switched off by setting <code>gmultitasking</code> parameter
to <code>FALSE</code>.</p>
</div>
<div id="limiting-the-memory-consumption" class="section level3">
<h3>Limiting the Memory Consumption</h3>
<p>For certain functions multitasking might result in higher memory
consumption. Users who have per process virtual memory limit (see:
<code>ulimit -v</code>) might be the first to suffer from memory
allocation errors.</p>
<p>Various factors can affect the memory usage such as the number of
running processes used for parallel computation, the value of
<code>gmax.data.size</code> option or the combination of both. Some of
the functions such as <code>gscreen</code> or <code>gextract</code>
consume in multitasking mode amount of memory proportional to
<code>gmax.data.size</code>. Please be aware of it while altering the
value of this option.</p>
<p>To limit memory consumption in multitasking mode one might lower down
the values of <code>gmax.data.size</code> and
<code>gmax.mem.usage</code> options or even switch off multitasking mode
completely. <code>gmax.mem.usage</code> indicates the upper limit in KB
of memory consumed cumulatively by the child processes. Once this limit
is breached an internal mechanism tries to pause some of the running
child processes, thereby preventing them from allocating more memory.
The paused processes are resumed once the memory consumption drops or
other sibling processes end.</p>
<p>One should not expect the internal limiting mechanism to be the
panacea for memory hungry tasks. First, the memory consumption of some
of the functions is proportional to <code>gmax.data.size</code> option
regardless of the number of running processes. Second, even when the
memory limit is exceeded at least one process is still left to run and
to potentially increase the memory consumption further. Third, the
mechanism is mainly periodic, i.e. excessive memory consumption is
detected only once in a while. The decision to pause running processes
is thus periodic as well. The memory that has already been consumed in
the time gap between the checks will not be release up until the whole
task is complete.</p>
<p>It is worth to say a word about memory consumption. Deducting real
memory usage of the process based on “top”, “ps” or other utilities of
similar kind might be highly misleading. Since all the processes are
spawned from R, their memory usage as reported by these utilities will
be at least as high as that of their parent process. If, for example, R
process uses 5 Gb of memory and 10 processes are spawned from it, the
virtual memory of all these 11 processes will top 55 Gb. Yet the
majority of the consumed memory will be shared and unless the child
processes start modifying this memory or allocating new one, the
physical free memory of the machine will remain almost unaltered. The
internal memory consumption limiting mechanism tries to estimate the
drop of system free memory and hence deducts its data from counting
“Private Dirty” bytes (on Linux) or from internal estimation (on other
platforms) - a very different datum from what “top” is reporting.</p>
</div>
<div id="other-considerations" class="section level3">
<h3>Other Considerations</h3>
<p>In multitasking mode the return value of <code>gquantiles</code> may
vary depending on the number of CPU cores. For more details please refer
the documentation of this function.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
